#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>

#include <CGAL/Point_set_3.h>
#include <CGAL/Point_set_3/IO.h>

#include <CGAL/remove_outliers.h>
#include <CGAL/grid_simplify_point_set.h>
#include <CGAL/jet_smooth_point_set.h>
#include <CGAL/jet_estimate_normals.h>
#include <CGAL/mst_orient_normals.h>

#include <CGAL/poisson_surface_reconstruction.h>
#include <CGAL/Advancing_front_surface_reconstruction.h>
#include <CGAL/Scale_space_surface_reconstruction_3.h>
#include <CGAL/Scale_space_reconstruction_3/Jet_smoother.h>
#include <CGAL/Scale_space_reconstruction_3/Advancing_front_mesher.h>

#include <CGAL/Polygon_mesh_processing/compute_normal.h>
#include <CGAL/Surface_mesh.h>
#include <CGAL/Polygon_mesh_processing/polygon_soup_to_polygon_mesh.h>

#include <cstdlib>
#include <vector>
#include <fstream>

// types
typedef CGAL::Exact_predicates_inexact_constructions_kernel Kernel;
typedef Kernel::FT FT;
typedef Kernel::Point_3 Point_3;
typedef Kernel::Vector_3 Vector_3;
typedef Kernel::Sphere_3 Sphere_3;
typedef CGAL::Point_set_3<Point_3, Vector_3> Point_set;

int main(int argc, char *argv[]) {

    Point_set points;

    if (argc == 2 && std::string(argv[1]) == "help") {
        std::cerr << "Usage: " << argv[0]
                  << " -in <input_file> -out <output_file> -method <0: avancing front, 1: scale space> \n "
                  << " -remove_outlier -apply_smooth  \n "
                  << "avancing front parameters: -radius_ratio_bound <value> -beta <value>\n "
                  << "scale space parameters: -maximum_facet_length <value> -iterations <value>\n\n";
        return 1;
    }

    std::string fname, output_file;
    double radius_ratio_bound = 2.0;
    double beta = 0.125;
    double maximum_facet_length = 0.5;
    int iterations = 4;
    int reconstruction_choice = 0;
    bool remove_outlier = false;
    bool apply_smooth = false;

    for (int i = 1; i < argc; ++i) {
        if (std::string(argv[i]) == "-in") {
            fname = argv[++i];
        } else if (std::string(argv[i]) == "-out") {
            output_file = argv[++i];
        }else if (std::string(argv[i]) == "-method") {
            reconstruction_choice = std::atoi(argv[++i]);
        } else if (std::string(argv[i]) == "-radius_ratio_bound") {
            radius_ratio_bound = std::stod(argv[++i]);
        } else if (std::string(argv[i]) == "-beta") {
            beta = std::stod(argv[++i]);
        }else if (std::string(argv[i]) == "-maximum_facet_length") {
            maximum_facet_length = std::stod(argv[++i]);
        } else if (std::string(argv[i]) == "-iterations") {
            iterations = std::stoi(argv[++i]);
        }
        else if (std::string(argv[i]) == "-remove_outlier") {
            remove_outlier = true;
        }
        else if (std::string(argv[i]) == "-apply_smooth") {
            apply_smooth = true;
        }
    }

    std::ifstream stream(fname, std::ios_base::binary);
    if (!stream) {
        std::cerr << "Error: cannot read file " << fname << std::endl;
        return EXIT_FAILURE;
    }

    stream >> points;

    std::cout << "Read " << points.size() << " point(s)" << std::endl;
    if (points.empty())
        return EXIT_FAILURE;

    if(remove_outlier){
        typename Point_set::iterator rout_it = CGAL::remove_outliers<CGAL::Sequential_tag>
                (points,
                 24, // Number of neighbors considered for evaluation
                 points.parameters().threshold_percent(5.0)); // Percentage of points to remove
        points.remove(rout_it, points.end());

        std::cout << points.number_of_removed_points()
                  << " point(s) are outliers." << std::endl;

        points.collect_garbage();
    }

    if(apply_smooth)
        CGAL::jet_smooth_point_set<CGAL::Sequential_tag>(points, 24);

    if (reconstruction_choice == 0) // Advancing front
    {

        typedef std::array<std::size_t, 3> Facet; // Triple of indices

        std::vector<Facet> facets;

        // The function is called using directly the points raw iterators
        CGAL::advancing_front_surface_reconstruction(points.points().begin(),
                                                     points.points().end(),
                                                     std::back_inserter(facets),
                                                     radius_ratio_bound,
                                                     beta);
        std::cout << facets.size()
                  << " facet(s) generated by reconstruction." << std::endl;



        // copy points for random access
        std::vector<Point_3> vertices;
        vertices.reserve(points.size());
        std::copy(points.points().begin(), points.points().end(), std::back_inserter(vertices));

        CGAL::Surface_mesh<Point_3> output_mesh;
        CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh(vertices, facets, output_mesh);

        std::ofstream f(output_file + ".off");
        if (!f) {
            std::cerr << "Cannot create output file.\n";
            return 1;
        }
        f << output_mesh;
        f.close();

    }
    else if (reconstruction_choice == 1) // Scale space
    {

        CGAL::Scale_space_surface_reconstruction_3<Kernel> reconstruct
                (points.points().begin(), points.points().end());

        // Smooth using 4 iterations of Jet Smoothing
        reconstruct.increase_scale(iterations, CGAL::Scale_space_reconstruction_3::Jet_smoother<Kernel>());
        // Mesh with the Advancing Front mesher with a maximum facet length of 0.5
        reconstruct.reconstruct_surface(CGAL::Scale_space_reconstruction_3::Advancing_front_mesher<Kernel>(maximum_facet_length));

        std::vector<Point_3> vertices;
        vertices.reserve(points.size());
        std::copy(points.points().begin(), points.points().end(), std::back_inserter(vertices));

        typedef std::array<std::size_t, 3> Facet;
        std::vector<Facet> facets;
        for (const auto& facet : CGAL::make_range (reconstruct.facets_begin(), reconstruct.facets_end()))
            facets.push_back(facet);

        CGAL::Surface_mesh<Point_3> output_mesh;
        CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh(vertices, facets, output_mesh);

        std::ofstream f(output_file + ".off");
        if (!f) {
            std::cerr << "Cannot create output file.\n";
            return 1;
        }
        f << output_mesh;
        f.close();

//        std::ofstream f(output_file + ".off");
//        if (!f) {
//            std::cerr << "Canno't create output file.\n";
//            return 1;
//        }
//
//        f << "OFF" << std::endl << points.size() << " "
//          << reconstruct.number_of_facets() << " 0" << std::endl;
//        for (Point_set::Index idx: points)
//            f << points.point(idx) << std::endl;
//        for (const auto &facet: CGAL::make_range(reconstruct.facets_begin(), reconstruct.facets_end()))
//            f << "3 " << facet[0] << " " << facet[1] << " " << facet[2] << std::endl;
//        f.close();

    } else // Handle error
    {
        std::cerr << "Error: invalid reconstruction id: " << reconstruction_choice << std::endl;
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}